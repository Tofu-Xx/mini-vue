function Vue(e={}){let{queueMicrotask:t,document:a,Reflect:r,Object:l,JSON:{stringify:n}}=window,d,s={},i=a.querySelector(e.el)??a,c=l.assign(new Proxy({$el:i,$refs:{}},{get:(...e)=>[r.get(...e),(s[e[1]]??=new Set).add(d)][0],set:(...e)=>[r.set(...e),t(()=>s[e[1]]?.forEach(e=>e?.()))][0]}),e.methods,e.data),o=n(c),u=RegExp(l.keys(c).map(e=>`(?<![\\w$])${e}(?![\\w$])`).join("|").replace(/\$/g,"\\$"),"g"),f=(e,t="return ")=>Function("$event",t+e.trim().replace(u,e=>"this."+e)).bind(c),$=e=>(d=e,e()),w=(e,t=a.createTreeWalker(e))=>{let{nodeType:r,data:l}=e;if(1==r)for(let{name:t,value:a}of e.attributes){let r=t.slice(1);"@"==t[0]&&e.addEventListener(r,/[^\s\w$]/.test(a)?f(a,""):c[a.trim()]?.bind(c)),":"==t[0]&&$(()=>e.setAttribute(r,e[r]=f(a)())),"ref"==t&&(c.$refs[a]=e)}3==r&&$(()=>e.data=l.replace(/\{\{(.*?)\}\}/gs,(e,t)=>f(t)())),t.nextNode()&&w(t.currentNode,t)};for(let[t,a]of l.entries(e.watch??{})){let e=c[t];s[t].add(()=>{let r=c[t];r!=e&&(a.call(c,r,e),e=r)})}e.created?.call(c),w(i),t(()=>{d=()=>{o!=(o=n(c))&&t(()=>{e.updated?.call(c),setTimeout(()=>o=null)})}}),e.mounted?.call(c)}
